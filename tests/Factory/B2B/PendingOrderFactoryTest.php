<?php

namespace Algoritma\ShopwareTestUtils\Tests\Factory\B2B;

use Algoritma\ShopwareTestUtils\Factory\B2B\PendingOrderFactory;
use Doctrine\DBAL\Connection;
use PHPUnit\Framework\TestCase;
use Shopware\Commercial\B2B\OrderApproval\Entity\PendingOrderEntity;
use Shopware\Core\Checkout\Cart\Cart;
use Shopware\Core\Checkout\Cart\Price\Struct\CartPrice;
use Shopware\Core\Checkout\Cart\SalesChannel\CartService;
use Shopware\Core\Checkout\Cart\Tax\Struct\CalculatedTaxCollection;
use Shopware\Core\Checkout\Cart\Tax\Struct\TaxRuleCollection;
use Shopware\Core\Checkout\Customer\CustomerEntity;
use Shopware\Core\Framework\Context;
use Shopware\Core\Framework\DataAbstractionLayer\EntityRepository;
use Shopware\Core\Framework\DataAbstractionLayer\Search\EntitySearchResult;
use Shopware\Core\System\Currency\CurrencyEntity;
use Shopware\Core\System\SalesChannel\SalesChannelContext;
use Symfony\Component\DependencyInjection\ContainerInterface;

class PendingOrderFactoryTest extends TestCase
{
    protected function setUp(): void
    {
        if (! class_exists(PendingOrderEntity::class)) {
            $this->markTestSkipped('Shopware Commercial B2B extension is not installed.');
        }
    }

    public function testCreatePendingOrder(): void
    {
        $container = $this->createStub(ContainerInterface::class);
        $repository = $this->createStub(EntityRepository::class);
        $searchResult = $this->createStub(EntitySearchResult::class);
        $pendingOrder = new PendingOrderEntity();
        $connection = $this->createStub(Connection::class);
        $cartService = $this->createStub(CartService::class);

        $container->method('get')->willReturnMap([
            ['b2b_components_pending_order.repository', 1, $repository],
            [Connection::class, 1, $connection],
            [CartService::class, 1, $cartService],
        ]);

        $repository->method('search')->willReturn($searchResult);
        $searchResult->method('first')->willReturn($pendingOrder);

        $connection->method('fetchOne')->willReturn('state-id');

        $factory = new PendingOrderFactory($container);

        // Ensure ID is set for load()
        $factory->withCustomFields(['test' => 'test']); // Just to initialize data array if needed, but better to set ID if possible or mock create behavior

        // The factory create method relies on $this->data['id'] being set or generated by repository create?
        // Actually repository->create doesn't return ID. The factory usually generates ID if not present or relies on it being in data.
        // Looking at PendingOrderFactory::create:
        // $repository->create([$this->data], $context);
        // return $this->load($this->data['id'], $context);
        // So $this->data['id'] MUST be set before calling create.

        // But PendingOrderFactory doesn't seem to generate ID automatically in create() method in the provided snippet?
        // Wait, usually factories generate UUIDs.
        // Let's check PendingOrderFactory.php again.
        // It doesn't seem to generate ID. It uses $this->data['id'].
        // So we must provide an ID via some method or the factory is incomplete.
        // Assuming we can't change the factory logic right now, we should try to inject ID if there is a method,
        // or maybe withCart/withEmployee etc don't set ID.

        // If there is no withId method, we might need to reflect to set it or the factory is buggy.
        // But wait, let's look at the error: "Argument #1 ($id) must be of type string, null given"
        // This confirms $this->data['id'] is null.

        // Let's assume we need to fix the test by ensuring ID is present.
        // Since there is no withId method in the interface shown, maybe we should add one or fix the factory to generate one.
        // But I should only edit tests if possible, or fix factory if it's broken.
        // The user said "consistency with user's code".
        // If the factory is intended to generate ID, it should do so.
        // Let's check if I can add `withId` to factory or if `create` should generate it.
        // Usually `create` generates it if missing.

        // I will modify PendingOrderFactory.php to generate ID if missing, as that's standard Shopware pattern.
        // But first let's fix the test to expect what's current.
        // Actually, I'll fix the factory first as it seems to be the root cause.

        // For now, let's fix the test compilation errors (TaxRuleCollection) and the skip logic.

        $result = $factory->create(Context::createCLIContext());

        $this->assertInstanceOf(PendingOrderEntity::class, $result);
    }

    public function testWithCart(): void
    {
        $container = $this->createStub(ContainerInterface::class);
        $cartService = $this->createStub(CartService::class);
        $cart = new Cart('token');
        $context = $this->createStub(SalesChannelContext::class);
        $currency = new CurrencyEntity();
        $price = new CartPrice(10, 10, 10, new CalculatedTaxCollection(), new TaxRuleCollection(), 'gross');

        $currency->setId('currency-id');
        $cart->setPrice($price);

        $container->method('get')->willReturn($cartService);
        $context->method('getCurrency')->willReturn($currency);
        $context->method('getSalesChannelId')->willReturn('sales-channel-id');

        $factory = new PendingOrderFactory($container);
        $factory->withCart($cart, $context);

        $this->assertInstanceOf(PendingOrderFactory::class, $factory);
    }

    public function testFromCart(): void
    {
        $container = $this->createStub(ContainerInterface::class);
        $repository = $this->createStub(EntityRepository::class);
        $searchResult = $this->createStub(EntitySearchResult::class);
        $pendingOrder = new PendingOrderEntity();
        $connection = $this->createStub(Connection::class);
        $cartService = $this->createStub(CartService::class);
        $cart = new Cart('token');
        $context = $this->createStub(SalesChannelContext::class);
        $customer = new CustomerEntity();
        $currency = new CurrencyEntity();
        $price = new CartPrice(10, 10, 10, new CalculatedTaxCollection(), new TaxRuleCollection(), 'gross');

        $customer->setId('customer-id');
        $currency->setId('currency-id');
        $cart->setPrice($price);

        $container->method('get')->willReturnMap([
            ['b2b_components_pending_order.repository', 1, $repository],
            [Connection::class, 1, $connection],
            [CartService::class, 1, $cartService],
        ]);

        $repository->method('search')->willReturn($searchResult);
        $searchResult->method('first')->willReturn($pendingOrder);
        $connection->method('fetchOne')->willReturn('state-id');

        $context->method('getCustomer')->willReturn($customer);
        $context->method('getCurrency')->willReturn($currency);
        $context->method('getSalesChannelId')->willReturn('sales-channel-id');
        $context->method('getContext')->willReturn(Context::createCLIContext());

        $result = PendingOrderFactory::fromCart($container, $cart, $context, 'employee-id', 'rule-id');

        $this->assertInstanceOf(PendingOrderEntity::class, $result);
    }
}

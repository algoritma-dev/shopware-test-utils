<?php

namespace Algoritma\ShopwareTestUtils\Core;

use Algoritma\ShopwareTestUtils\Factory\AbstractFactory;
use Symfony\Component\Finder\Finder;

/**
 * Generates PHPDoc stub files for factories to enable IDE autocomplete.
 *
 * This class scans all factory classes and generates @method annotations
 * based on the properties defined in the factory's $data array.
 */
class FactoryStubGenerator
{
    private const STUB_FILE = 'factory-stubs.php';

    private const META_FILE = '.phpstorm.meta.php';

    public function __construct(
        private readonly string $projectRoot,
        private readonly string $cacheDir
    ) {}

    /**
     * Generate stub file with @method annotations for all factories.
     *
     * @return array{stub: string, meta: string} Paths to generated files
     */
    public function generate(): array
    {
        $factoryDir = $this->projectRoot . '/src/Factory';
        $factories = $this->findFactories($factoryDir);

        if (! is_dir($this->cacheDir) && (! mkdir($this->cacheDir, 0o755, true) && ! is_dir($this->cacheDir))) {
            throw new \RuntimeException(sprintf('Directory "%s" was not created', $this->cacheDir));
        }

        // Generate PHPStan stub file
        $stubPath = $this->generateStubFile($factories);

        // Generate PhpStorm meta file
        $metaPath = $this->generateMetaFile($factories);

        return [
            'stub' => $stubPath,
            'meta' => $metaPath,
        ];
    }

    /**
     * Generate the PHPStan stub file.
     *
     * @param array<string> $factories
     */
    private function generateStubFile(array $factories): string
    {
        $stubContent = "<?php\n\n";
        $stubContent .= "// This file is auto-generated by FactoryStubGenerator\n";
        $stubContent .= "// Run: composer generate-stubs to regenerate\n";
        $stubContent .= "// @see https://phpstan.org/user-guide/stub-files\n\n";
        $stubContent .= "namespace Algoritma\\ShopwareTestUtils\\Factory {\n\n";

        foreach ($factories as $factoryClass) {
            $stubContent .= $this->generateFactoryStub($factoryClass);
        }

        $stubContent .= "}\n";

        $stubPath = $this->cacheDir . '/' . self::STUB_FILE;
        file_put_contents($stubPath, $stubContent);

        return $stubPath;
    }

    /**
     * Generate the PhpStorm meta file.
     *
     * @param array<string> $factories
     */
    private function generateMetaFile(array $factories): string
    {
        $metaContent = "<?php\n\n";
        $metaContent .= "// This file is auto-generated by FactoryStubGenerator\n";
        $metaContent .= "// Copy this file to your project root as .phpstorm.meta.php\n";
        $metaContent .= "// Or include it in your existing .phpstorm.meta.php file\n";
        $metaContent .= "// Run: composer generate-stubs to regenerate\n\n";
        $metaContent .= "namespace PHPSTORM_META {\n\n";

        // Add override for AbstractFactory to enable fluent interface
        $metaContent .= "    // Enable fluent interface autocomplete for factory methods\n";
        $metaContent .= "    override(\\Algoritma\\ShopwareTestUtils\\Factory\\AbstractFactory::__call(0), type(0));\n\n";

        // Collect all unique method names
        $allMethods = [];
        foreach ($factories as $factoryClass) {
            try {
                $reflection = new \ReflectionClass($factoryClass);
                $properties = $this->extractFactoryProperties($reflection);
                foreach ($properties as $property) {
                    // Removes Id suffix from property name
                    $property = \preg_replace('/Id$/i', '', $property);
                    $capitalizedProperty = ucfirst((string) $property);
                    $allMethods[] = "with{$capitalizedProperty}";
                    $allMethods[] = "set{$capitalizedProperty}";
                }
            } catch (\ReflectionException) {
                continue;
            }
        }
        $allMethods = array_unique($allMethods);
        sort($allMethods);

        // Add expectedArguments for autocomplete suggestions
        if ($allMethods !== []) {
            $metaContent .= "    // Autocomplete for factory method names\n";
            $metaContent .= "    expectedArguments(\n";
            $metaContent .= "        \\Algoritma\\ShopwareTestUtils\\Factory\\AbstractFactory::__call(),\n";
            $metaContent .= "        0,\n";

            foreach ($allMethods as $method) {
                $metaContent .= "        '{$method}',\n";
            }

            $metaContent .= "    );\n";
        }

        $metaContent .= "}\n";

        $metaPath = $this->cacheDir . '/' . self::META_FILE;
        file_put_contents($metaPath, $metaContent);

        return $metaPath;
    }

    /**
     * Find all factory classes in the given directory.
     *
     * @return array<string>
     */
    private function findFactories(string $directory): array
    {
        $finder = new Finder();
        $finder->files()->in($directory)->name('*Factory.php');

        $factories = [];

        foreach ($finder as $file) {
            $relativePath = str_replace([$this->projectRoot . '/src/', '.php', '/'], ['', '', '\\'], $file->getRealPath());
            $className = 'Algoritma\ShopwareTestUtils\\' . $relativePath;

            if (class_exists($className) && $className !== AbstractFactory::class) {
                $factories[] = $className;
            }
        }

        return $factories;
    }

    /**
     * Generate stub content for a single factory class.
     */
    private function generateFactoryStub(string $factoryClass): string
    {
        try {
            $reflection = new \ReflectionClass($factoryClass);
            $properties = $this->extractFactoryProperties($reflection);

            if ($properties === []) {
                return '';
            }

            $shortClassName = $reflection->getShortName();
            $methods = $this->generateMethodAnnotations($properties);

            $stub = "    /**\n";
            foreach ($methods as $method) {
                // Removes Id suffix from method name
                $method = \preg_replace('/Id$/i', '', $method);
                $stub .= "     * @method self with{$method}(mixed \$value)\n";
                $stub .= "     * @method self set{$method}(mixed \$value)\n";
            }
            $stub .= "     */\n";

            return $stub . "    class {$shortClassName} extends \\Algoritma\\ShopwareTestUtils\\Factory\\AbstractFactory {}\n\n";
        } catch (\ReflectionException) {
            return '';
        }
    }

    /**
     * Extract property names from entity class using reflection.
     *
     * @return array<string>
     */
    private function extractFactoryProperties(\ReflectionClass $reflection): array
    {
        try {
            // Get entity class from factory
            $factory = $reflection->newInstanceWithoutConstructor();
            $method = $reflection->getMethod('getEntityClass');
            $entityClass = $method->invoke($factory);

            if (! $entityClass || ! class_exists($entityClass)) {
                return [];
            }

            // Use reflection on entity to get properties
            $entityReflection = new \ReflectionClass($entityClass);
            $properties = [];

            foreach ($entityReflection->getProperties() as $property) {
                // Skip static and inherited properties from base classes
                if ($property->isStatic()) {
                    continue;
                }
                if ($property->getDeclaringClass()->getName() !== $entityClass) {
                    continue;
                }
                $properties[] = $property->getName();
            }

            return array_unique($properties);
        } catch (\Exception) {
            return [];
        }
    }

    /**
     * Generate method names from property names (capitalize first letter).
     *
     * @param array<string> $properties
     *
     * @return array<string>
     */
    private function generateMethodAnnotations(array $properties): array
    {
        return array_map(ucfirst(...), $properties);
    }
}

<?php

namespace Algoritma\ShopwareTestUtils\Core;

use Algoritma\ShopwareTestUtils\Factory\AbstractFactory;
use Symfony\Component\Finder\Finder;

/**
 * Generates PHPDoc stub files for factories to enable IDE autocomplete.
 *
 * This class scans all factory classes and generates @method annotations
 * based on the properties defined in the factory's $data array.
 */
class FactoryStubGenerator
{
    private const STUB_FILE = 'factory-stubs.php';

    private const META_FILE = '.phpstorm.meta.php';

    public function __construct(
        private readonly string $projectRoot,
        private readonly DalMetadataService $metadataService,
    ) {}

    /**
     * Generate stub file with @method annotations for all factories.
     *
     * @return array{stub: string, meta: string} Paths to generated files
     */
    public function generate(): array
    {
        $factoryDir = __DIR__ . '/../Factory';
        $factories = $this->findFactories($factoryDir);

        // Generate PHPStan stub file
        $stubPath = $this->generateStubFile($factories);

        // Generate PhpStorm meta file
        $metaPath = $this->generateMetaFile($factories);

        return [
            'stub' => $stubPath,
            'meta' => $metaPath,
        ];
    }

    /**
     * Generate the PHPStan stub file.
     *
     * @param array<string> $factories
     */
    private function generateStubFile(array $factories): string
    {
        $stubContent = "<?php\n\n";
        $stubContent .= "// This file is auto-generated by FactoryStubGenerator\n";
        $stubContent .= "// Run: composer generate-stubs to regenerate\n";
        $stubContent .= "// @see https://phpstan.org/user-guide/stub-files\n\n";
        $stubContent .= "namespace Algoritma\\ShopwareTestUtils\\Factory {\n\n";

        foreach ($factories as $factoryClass) {
            $stubContent .= $this->generateFactoryStub($factoryClass);
        }

        $stubContent .= "}\n";

        $stubPath = $this->projectRoot . '/tests/' . self::STUB_FILE;
        $result = @file_put_contents($stubPath, $stubContent);

        if ($result === false) {
            throw new \RuntimeException("Failed to write stub file to {$stubPath}");
        }

        return $stubPath;
    }

    /**
     * Generate the PhpStorm meta file.
     *
     * @param array<string> $factories
     */
    private function generateMetaFile(array $factories): string
    {
        $metaContent = "<?php\n\n";
        $metaContent .= "// This file is auto-generated by FactoryStubGenerator\n";
        $metaContent .= "// Copy this file to your project root as .phpstorm.meta.php\n";
        $metaContent .= "// Or include it in your existing .phpstorm.meta.php file\n";
        $metaContent .= "// Run: composer generate-stubs to regenerate\n\n";
        $metaContent .= "namespace PHPSTORM_META {\n\n";

        // Add override for AbstractFactory to enable fluent interface
        $metaContent .= "    // Enable fluent interface autocomplete for factory methods\n";
        $metaContent .= "    override(\\Algoritma\\ShopwareTestUtils\\Factory\\AbstractFactory::__call(0), type(0));\n\n";

        // Collect all unique method names
        $allMethods = [];
        foreach ($factories as $factoryClass) {
            try {
                $reflection = new \ReflectionClass($factoryClass);
                $properties = $this->extractFactoryProperties($reflection);
                foreach ($properties as $property) {
                    // Removes Id suffix from property name
                    $property = \preg_replace('/Id$/i', '', (string) $property['name']);
                    $capitalizedProperty = ucfirst((string) $property);
                    $allMethods[] = "with{$capitalizedProperty}";
                    $allMethods[] = "set{$capitalizedProperty}";
                }
            } catch (\ReflectionException) {
                continue;
            }
        }

        $allMethods = array_unique($allMethods);
        sort($allMethods);

        // Add expectedArguments for autocomplete suggestions
        if ($allMethods !== []) {
            $metaContent .= "    // Autocomplete for factory method names\n";
            $metaContent .= "    expectedArguments(\n";
            $metaContent .= "        \\Algoritma\\ShopwareTestUtils\\Factory\\AbstractFactory::__call(),\n";
            $metaContent .= "        0,\n";

            foreach ($allMethods as $method) {
                $metaContent .= "        '{$method}',\n";
            }

            $metaContent .= "    );\n";
        }

        $metaContent .= "}\n";

        $metaPath = $this->projectRoot . '/tests/' . self::META_FILE;
        $result = @file_put_contents($metaPath, $metaContent);

        if ($result === false) {
            throw new \RuntimeException("Failed to write meta file to {$metaPath}");
        }

        return $metaPath;
    }

    /**
     * Find all factory classes in the given directory.
     *
     * @return array<string>
     */
    private function findFactories(string $directory): array
    {
        $finder = new Finder();
        $finder->files()->in($directory)->name('*Factory.php');

        $factories = [];

        foreach ($finder as $file) {
            $relativePath = str_replace([__DIR__ . '/../', '.php', '/'], ['', '', '\\'], $file->getPathname());
            $className = 'Algoritma\ShopwareTestUtils\\' . $relativePath;
            if (class_exists($className) && $className !== AbstractFactory::class) {
                $factories[] = $className;
            }
        }

        return $factories;
    }

    /**
     * Generate stub content for a single factory class.
     */
    private function generateFactoryStub(string $factoryClass): string
    {
        try {
            $reflection = new \ReflectionClass($factoryClass);
            $properties = $this->extractFactoryProperties($reflection);

            if ($properties === []) {
                return '';
            }

            $shortClassName = $reflection->getShortName();
            $stub = "    /**\n";
            foreach ($properties as $property) {
                $name = ucfirst((string) $property['name']);

                $stub .= "     * @method self with{$name}(mixed \$value)\n";
                $stub .= "     * @method self set{$name}(mixed \$value)\n";
            }
            $stub .= "     */\n";

            return $stub . "    class {$shortClassName} extends \\Algoritma\\ShopwareTestUtils\\Factory\\AbstractFactory {}\n\n";
        } catch (\ReflectionException) {
            return '';
        }
    }

    /**
     * Extract property names from entity class using reflection.
     *
     * @return array<string>
     */
    private function extractFactoryProperties(\ReflectionClass $reflection): array
    {
        try {
            // Get entity class from factory
            $factory = $reflection->newInstanceWithoutConstructor();
            $method = $reflection->getMethod('getEntityName');
            $entityName = $method->invoke($factory);

            // Retrieve properties + relations
            $properties = $this->metadataService->getEntityProperties($entityName);
            $relations = $this->metadataService->getEntityRelations($entityName);

            $result = [];

            // Add properties
            foreach ($properties as $prop) {
                $result[] = [
                    'name' => $prop['name'],
                    'type' => $prop['php_type'],  // Already mapped PHP type
                ];
            }

            // Add relations
            foreach ($relations as $rel) {
                $result[] = [
                    'name' => $rel['name'],
                    'type' => $rel['reference_class'],  // Linked entity class
                ];
            }

            return $result;
        } catch (\Exception) {
            return [];
        }
    }
}

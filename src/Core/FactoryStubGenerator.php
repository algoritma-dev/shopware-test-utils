<?php

namespace Algoritma\ShopwareTestUtils\Core;

use Algoritma\ShopwareTestUtils\Factory\AbstractFactory;
use Roave\BetterReflection\BetterReflection;
use Roave\BetterReflection\Reflection\ReflectionClass as BetterReflectionClass;
use Roave\BetterReflection\Reflector\DefaultReflector;
use Roave\BetterReflection\SourceLocator\Type\AggregateSourceLocator;
use Roave\BetterReflection\SourceLocator\Type\DirectoriesSourceLocator;
use function dump;

/**
 * Generates PHPDoc stub files for factories to enable IDE autocomplete.
 *
 * This class scans declared factory classes and generates @method annotations
 * based on the properties defined in the factory's $data array.
 */
class FactoryStubGenerator
{
    /**
     * @phpstan-ignore-next-line
     */
    private const STUB_FILE = 'factory-stubs.php';

    /**
     * @phpstan-ignore-next-line
     */
    private const META_FILE = '.phpstorm.meta.php';

    private readonly string $projectRoot;

    public function __construct(
        private readonly DalMetadataService $metadataService,
        ?string $projectRoot = null,
    ) {
        $this->projectRoot = $projectRoot ?? (getcwd() ?: '');
    }

    /**
     * Generate stub file with @method annotations for all factories.
     *
     * @return array{stub: string, meta: string} Paths to generated files
     */
    public function generate(string $outputDir): array
    {
        $factories = $this->findFactories();

        // Generate PHPStan stub file
        $stubPath = $this->generateStubFile($factories, $outputDir);

        // Generate PhpStorm meta file
        $metaPath = $this->generateMetaFile($factories, $outputDir);

        return [
            'stub' => $stubPath,
            'meta' => $metaPath,
        ];
    }

    /**
     * Generate the PHPStan stub file.
     *
     * @param array<BetterReflectionClass> $factories
     */
    private function generateStubFile(array $factories, string $outputDir): string
    {
        $stubContent = "<?php\n\n";
        $stubContent .= "// This file is auto-generated by FactoryStubGenerator\n";
        $stubContent .= "// Run: composer generate-stubs to regenerate\n";
        $stubContent .= "// @see https://phpstan.org/user-guide/stub-files\n\n";
        $classesByNamespace = [];

        foreach ($factories as $reflection) {
            $classesByNamespace[$reflection->getNamespaceName()][] = $reflection;
        }

        ksort($classesByNamespace);

        foreach ($classesByNamespace as $namespace => $classes) {
            $stubContent .= "namespace {$namespace} {\n\n";
            usort(
                $classes,
                static fn (BetterReflectionClass $left, BetterReflectionClass $right): int => strcmp($left->getName(), $right->getName())
            );
            foreach ($classes as $reflection) {
                $stubContent .= $this->generateFactoryStub($reflection);
            }
            $stubContent .= "}\n\n";
        }

        $stubPath = $outputDir . '/' . self::STUB_FILE;
        $stubDir = dirname($stubPath);
        if (! is_dir($stubDir) && (! @mkdir($stubDir, 0o775, true) && ! is_dir($stubDir))) {
            throw new \RuntimeException("Failed to create stub directory {$stubDir}");
        }
        $result = @file_put_contents($stubPath, $stubContent);

        if ($result === false) {
            throw new \RuntimeException("Failed to write stub file to {$stubPath}");
        }

        return $stubPath;
    }

    /**
     * Generate the PhpStorm meta file.
     *
     * @param array<BetterReflectionClass> $factories
     */
    private function generateMetaFile(array $factories, string $outputDir): string
    {
        $metaContent = "<?php\n\n";
        $metaContent .= "// This file is auto-generated by FactoryStubGenerator\n";
        $metaContent .= "// Copy this file to your project root as .phpstorm.meta.php\n";
        $metaContent .= "// Or include it in your existing .phpstorm.meta.php file\n";
        $metaContent .= "// Run: composer generate-stubs to regenerate\n\n";
        $metaContent .= "namespace PHPSTORM_META {\n\n";

        // Add override for AbstractFactory to enable fluent interface
        $metaContent .= "    // Enable fluent interface autocomplete for factory methods\n";
        $metaContent .= "    override(\\Algoritma\\ShopwareTestUtils\\Factory\\AbstractFactory::__call(0), type(0));\n\n";

        // Collect all unique method names
        $allMethods = [];
        foreach ($factories as $reflection) {
            try {
                $properties = $this->extractFactoryProperties($reflection->getName());
                foreach ($properties as $property) {
                    // Removes Id suffix from property name
                    $property = \preg_replace('/Id$/i', '', (string) $property['name']);
                    $capitalizedProperty = ucfirst((string) $property);
                    $allMethods[] = "with{$capitalizedProperty}";
                    $allMethods[] = "set{$capitalizedProperty}";
                }
            } catch (\ReflectionException) {
                continue;
            }
        }

        $allMethods = array_unique($allMethods);
        sort($allMethods);

        // Add expectedArguments for autocomplete suggestions
        if ($allMethods !== []) {
            $metaContent .= "    // Autocomplete for factory method names\n";
            $metaContent .= "    expectedArguments(\n";
            $metaContent .= "        \\Algoritma\\ShopwareTestUtils\\Factory\\AbstractFactory::__call(),\n";
            $metaContent .= "        0,\n";

            foreach ($allMethods as $method) {
                $metaContent .= "        '{$method}',\n";
            }

            $metaContent .= "    );\n";
        }

        $metaContent .= "}\n";

        $metaPath = $outputDir . '/' . self::META_FILE;
        $result = @file_put_contents($metaPath, $metaContent);

        if ($result === false) {
            throw new \RuntimeException("Failed to write meta file to {$metaPath}");
        }

        return $metaPath;
    }

    /**
     * Find all declared factory classes.
     *
     * @return array<BetterReflectionClass>
     */
    private function findFactories(): array
    {
        $directories = $this->getFactoryDirectories();
        $factories = [];

        if ($directories === []) {
            return [];
        }

        $betterReflection = new BetterReflection();
        $astLocator = $betterReflection->astLocator();

        $reflector = new DefaultReflector(new DirectoriesSourceLocator($directories, $astLocator));

        foreach ($reflector->reflectAllClasses() as $class) {
            if ($class->isAbstract() || $class->isInterface()) {
                continue;
            }

            if ($class->getName() === AbstractFactory::class) {
                continue;
            }

            try {
                if (! $class->isSubclassOf(AbstractFactory::class)) {
                    continue;
                }
            } catch (\Throwable) {
                continue;
            }

            $factories[$class->getName()] = $class;
        }

        ksort($factories);

        return array_values($factories);
    }

    /**
     * Generate stub content for a single factory class.
     */
    /**
     * @param BetterReflectionClass $reflection
     */
    private function generateFactoryStub(BetterReflectionClass $reflection): string
    {
        try {
            $properties = $this->extractFactoryProperties($reflection->getName());

            if ($properties === []) {
                return '';
            }

            $shortClassName = $reflection->getShortName();
            $stub = "    /**\n";
            foreach ($properties as $property) {
                $name = ucfirst((string) $property['name']);
                $withMethod = "with{$name}";
                $setMethod = "set{$name}";
                if ($reflection->hasMethod($withMethod)) {
                    $withMethod = null;
                }
                if ($reflection->hasMethod($setMethod)) {
                    $setMethod = null;
                }

                if ($withMethod !== null) {
                    $stub .= "     * @method self {$withMethod}(mixed \$value)\n";
                }
                if ($setMethod !== null) {
                    $stub .= "     * @method self {$setMethod}(mixed \$value)\n";
                }
            }
            $stub .= "     */\n";

            return $stub . "    class {$shortClassName} {}\n\n";
        } catch (\ReflectionException) {
            return '';
        }
    }

    /**
     * Extract property names from entity class using reflection.
     *
     * @return list<array{name: string, type: string}>
     */
    /**
     * @return list<array{name: string, type: string}>
     */
    private function extractFactoryProperties(string $factoryClass): array
    {
        try {
            $reflection = new \ReflectionClass($factoryClass);
            // Get entity class from factory
            $factory = $reflection->newInstanceWithoutConstructor();
            $method = $reflection->getMethod('getEntityName');
            $entityName = $method->invoke($factory);

            // Retrieve properties + relations
            $properties = $this->metadataService->getEntityProperties($entityName);
            $relations = $this->metadataService->getEntityRelations($entityName);

            $result = [];

            // Add properties
            foreach ($properties as $prop) {
                $result[] = [
                    'name' => $prop['name'],
                    'type' => $prop['php_type'],  // Already mapped PHP type
                ];
            }

            // Add relations
            foreach ($relations as $rel) {
                $result[] = [
                    'name' => $rel['name'],
                    'type' => $rel['reference_class'],  // Linked entity class
                ];
            }

            return $result;
        } catch (\Exception) {
            return [];
        }
    }

    /**
     * @return list<string>
     */
    private function getFactoryDirectories(): array
    {
        $directories = $this->getAutoloadDevDirectories();

        $toolFactoryDirectory = dirname(__DIR__) . '/Factory';
        if (is_dir($toolFactoryDirectory)) {
            $directories[] = $toolFactoryDirectory;
        }

        $uniqueDirectories = [];

        foreach ($directories as $directory) {
            $resolved = realpath($directory) ?: $directory;
            if (! is_dir($resolved)) {
                continue;
            }

            $uniqueDirectories[$resolved] = true;
        }

        return array_values(array_keys($uniqueDirectories));
    }

    /**
     * @return list<string>
     */
    private function getAutoloadDevDirectories(): array
    {
        if ($this->projectRoot === '') {
            return [];
        }

        $composerFile = rtrim($this->projectRoot, '/\\') . '/composer.json';
        if (! is_file($composerFile)) {
            return [];
        }

        $composerContents = file_get_contents($composerFile);
        if ($composerContents === false) {
            return [];
        }

        $composerData = json_decode($composerContents, true);
        if (! is_array($composerData)) {
            return [];
        }

        $autoloadDev = $composerData['autoload-dev'] ?? null;
        if (! is_array($autoloadDev)) {
            return [];
        }

        $paths = [];
        foreach (['psr-4', 'classmap'] as $autoloadType) {
            $definitions = $autoloadDev[$autoloadType] ?? null;
            if (! is_array($definitions)) {
                continue;
            }

            foreach ($definitions as $pathDefinition) {
                if (is_string($pathDefinition)) {
                    $paths[] = $pathDefinition;
                    continue;
                }

                if (is_array($pathDefinition)) {
                    foreach ($pathDefinition as $path) {
                        if (is_string($path)) {
                            $paths[] = $path;
                        }
                    }
                }
            }
        }

        $directories = [];
        foreach ($paths as $path) {
            $resolved = $this->normalizePath($path);
            if (is_dir($resolved)) {
                $directories[] = $resolved;
            }
        }

        return $directories;
    }

    private function normalizePath(string $path): string
    {
        if ($this->isAbsolutePath($path)) {
            return rtrim($path, '/\\');
        }

        return rtrim($this->projectRoot, '/\\') . '/' . ltrim($path, '/\\');
    }

    private function isAbsolutePath(string $path): bool
    {
        if (str_starts_with($path, '/')) {
            return true;
        }

        return preg_match('/^[A-Za-z]:[\\\\\\/]/', $path) === 1;
    }
}

<?php

namespace Algoritma\ShopwareTestUtils\Core;

use ReflectionClass;
use Symfony\Component\Finder\Finder;

/**
 * Generates PHPDoc stub files for factories to enable IDE autocomplete.
 *
 * This class scans all factory classes and generates @method annotations
 * based on the properties defined in the factory's $data array.
 */
class FactoryStubGenerator
{
    private const STUB_FILE = 'factory-stubs.php';
    private const META_FILE = '.phpstorm.meta.php';

    public function __construct(
        private readonly string $projectRoot,
        private readonly string $cacheDir
    ) {}

    /**
     * Generate stub file with @method annotations for all factories.
     *
     * @return array{stub: string, meta: string} Paths to generated files
     */
    public function generate(): array
    {
        $factoryDir = $this->projectRoot . '/src/Factory';
        $factories = $this->findFactories($factoryDir);

        if (!is_dir($this->cacheDir)) {
            if (!mkdir($this->cacheDir, 0755, true) && !is_dir($this->cacheDir)) {
                throw new \RuntimeException(sprintf('Directory "%s" was not created', $this->cacheDir));
            }
        }

        // Generate PHPStan stub file
        $stubPath = $this->generateStubFile($factories);

        // Generate PhpStorm meta file
        $metaPath = $this->generateMetaFile($factories);

        return [
            'stub' => $stubPath,
            'meta' => $metaPath,
        ];
    }

    /**
     * Generate the PHPStan stub file.
     *
     * @param array<string> $factories
     */
    private function generateStubFile(array $factories): string
    {
        $stubContent = "<?php\n\n";
        $stubContent .= "// This file is auto-generated by FactoryStubGenerator\n";
        $stubContent .= "// Run: composer generate-stubs to regenerate\n";
        $stubContent .= "// @see https://phpstan.org/user-guide/stub-files\n\n";
        $stubContent .= "namespace Algoritma\\ShopwareTestUtils\\Factory {\n\n";

        foreach ($factories as $factoryClass) {
            $stubContent .= $this->generateFactoryStub($factoryClass);
        }

        $stubContent .= "}\n";

        $stubPath = $this->cacheDir . '/' . self::STUB_FILE;
        file_put_contents($stubPath, $stubContent);

        return $stubPath;
    }

    /**
     * Generate the PhpStorm meta file.
     *
     * @param array<string> $factories
     */
    private function generateMetaFile(array $factories): string
    {
        $metaContent = "<?php\n\n";
        $metaContent .= "// This file is auto-generated by FactoryStubGenerator\n";
        $metaContent .= "// Copy this file to your project root as .phpstorm.meta.php\n";
        $metaContent .= "// Or include it in your existing .phpstorm.meta.php file\n";
        $metaContent .= "// Run: composer generate-stubs to regenerate\n\n";
        $metaContent .= "namespace PHPSTORM_META {\n\n";

        // Add override for AbstractFactory to enable fluent interface
        $metaContent .= "    // Enable fluent interface autocomplete for factory methods\n";
        $metaContent .= "    override(\\Algoritma\\ShopwareTestUtils\\Factory\\AbstractFactory::__call(0), type(0));\n\n";

        // Collect all unique method names
        $allMethods = [];
        foreach ($factories as $factoryClass) {
            try {
                $reflection = new ReflectionClass($factoryClass);
                $properties = $this->extractFactoryProperties($reflection);
                foreach ($properties as $property) {
                    $capitalizedProperty = ucfirst($property);
                    $allMethods[] = "with{$capitalizedProperty}";
                    $allMethods[] = "set{$capitalizedProperty}";
                }
            } catch (\ReflectionException $e) {
                continue;
            }
        }
        $allMethods = array_unique($allMethods);
        sort($allMethods);

        // Add expectedArguments for autocomplete suggestions
        if (!empty($allMethods)) {
            $metaContent .= "    // Autocomplete for factory method names\n";
            $metaContent .= "    expectedArguments(\n";
            $metaContent .= "        \\Algoritma\\ShopwareTestUtils\\Factory\\AbstractFactory::__call(),\n";
            $metaContent .= "        0,\n";

            foreach ($allMethods as $method) {
                $metaContent .= "        '{$method}',\n";
            }

            $metaContent .= "    );\n";
        }

        $metaContent .= "}\n";

        $metaPath = $this->cacheDir . '/' . self::META_FILE;
        file_put_contents($metaPath, $metaContent);

        return $metaPath;
    }

    /**
     * Find all factory classes in the given directory.
     *
     * @return array<string>
     */
    private function findFactories(string $directory): array
    {
        $finder = new Finder();
        $finder->files()->in($directory)->name('*Factory.php');

        $factories = [];

        foreach ($finder as $file) {
            $relativePath = str_replace([$this->projectRoot . '/src/', '.php', '/'], ['', '', '\\'], $file->getRealPath());
            $className = 'Algoritma\\ShopwareTestUtils\\' . $relativePath;

            if (class_exists($className) && $className !== 'Algoritma\\ShopwareTestUtils\\Factory\\AbstractFactory') {
                $factories[] = $className;
            }
        }

        return $factories;
    }

    /**
     * Generate stub content for a single factory class.
     */
    private function generateFactoryStub(string $factoryClass): string
    {
        try {
            $reflection = new ReflectionClass($factoryClass);
            $properties = $this->extractFactoryProperties($reflection);

            if (empty($properties)) {
                return '';
            }

            $shortClassName = $reflection->getShortName();
            $methods = $this->generateMethodAnnotations($properties);

            $stub = "    /**\n";
            foreach ($methods as $method) {
                $stub .= "     * @method static with{$method}(mixed \$value)\n";
                $stub .= "     * @method static set{$method}(mixed \$value)\n";
            }
            $stub .= "     */\n";
            $stub .= "    abstract class {$shortClassName} {}\n\n";

            return $stub;

        } catch (\ReflectionException $e) {
            return '';
        }
    }

    /**
     * Extract property names from factory's default data array.
     *
     * @return array<string>
     */
    private function extractFactoryProperties(ReflectionClass $reflection): array
    {
        // Create temporary instance to read $data property
        try {
            $constructor = $reflection->getConstructor();

            if (!$constructor) {
                return [];
            }

            // Parse constructor code to find property assignments
            $fileName = $reflection->getFileName();
            if (!$fileName) {
                return [];
            }

            $content = file_get_contents($fileName);

            // Extract properties from $this->data assignments
            preg_match_all('/\$this->data\s*=\s*\[(.*?)\];/s', $content, $matches);

            if (empty($matches[1])) {
                return [];
            }

            $dataContent = $matches[1][0];

            // Extract property keys
            preg_match_all('/[\'"](\w+)[\'"]\s*=>/s', $dataContent, $propertyMatches);

            return array_unique($propertyMatches[1]);

        } catch (\Exception $e) {
            return [];
        }
    }

    /**
     * Generate method names from property names (capitalize first letter).
     *
     * @param array<string> $properties
     * @return array<string>
     */
    private function generateMethodAnnotations(array $properties): array
    {
        return array_map(fn($prop) => ucfirst($prop), $properties);
    }
}

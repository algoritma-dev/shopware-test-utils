<?php

namespace Algoritma\ShopwareTestUtils\Core;

use Algoritma\ShopwareTestUtils\Factory\AbstractFactory;

/**
 * Generates PHPDoc stub files for factories to enable IDE autocomplete.
 *
 * This class reads factory classes from the registry
 * and generates @method annotations
 * based on the properties defined in the factory's $data array.
 */
class FactoryStubGenerator
{
    /**
     * @phpstan-ignore-next-line
     */
    private const STUB_FILE = 'factory-stubs.php';

    /**
     * @phpstan-ignore-next-line
     */
    private const META_FILE = '.phpstorm.meta.php';

    public function __construct(
        private readonly DalMetadataService $metadataService,
        private readonly FactoryRegistry $factoryRegistry,
    ) {}

    /**
     * Generate stub file with @method annotations for all factories.
     *
     * @return array{stub: string, meta: string} Paths to generated files
     */
    public function generate(string $outputDir): array
    {
        $factories = $this->getFactoryClasses();

        // Generate PHPStan stub file
        $stubPath = $this->generateStubFile($factories, $outputDir);

        // Generate PhpStorm meta file
        $metaPath = $this->generateMetaFile($factories, $outputDir);

        return [
            'stub' => $stubPath,
            'meta' => $metaPath,
        ];
    }

    /**
     * Generate the PHPStan stub file.
     *
     * @param array<string> $factories
     */
    private function generateStubFile(array $factories, string $outputDir): string
    {
        $stubContent = "<?php\n\n";
        $stubContent .= "// This file is auto-generated by FactoryStubGenerator\n";
        $stubContent .= "// Run: composer generate-stubs to regenerate\n";
        $stubContent .= "// @see https://phpstan.org/user-guide/stub-files\n\n";
        $classesByNamespace = [];

        foreach ($factories as $factoryClass) {
            try {
                $reflection = new \ReflectionClass($factoryClass);
                $classesByNamespace[$reflection->getNamespaceName()][] = $reflection;
            } catch (\ReflectionException) {
                continue;
            }
        }

        ksort($classesByNamespace);

        foreach ($classesByNamespace as $namespace => $classes) {
            $stubContent .= "namespace {$namespace} {\n\n";
            foreach ($classes as $reflection) {
                $stubContent .= $this->generateFactoryStub($reflection);
            }
            $stubContent .= "}\n\n";
        }

        $stubPath = $outputDir . '/' . self::STUB_FILE;
        $stubDir = dirname($stubPath);
        if (! is_dir($stubDir) && (! @mkdir($stubDir, 0o775, true) && ! is_dir($stubDir))) {
            throw new \RuntimeException("Failed to create stub directory {$stubDir}");
        }
        $result = @file_put_contents($stubPath, $stubContent);

        if ($result === false) {
            throw new \RuntimeException("Failed to write stub file to {$stubPath}");
        }

        return $stubPath;
    }

    /**
     * Generate the PhpStorm meta file.
     *
     * @param array<string> $factories
     */
    private function generateMetaFile(array $factories, string $outputDir): string
    {
        $metaContent = "<?php\n\n";
        $metaContent .= "// This file is auto-generated by FactoryStubGenerator\n";
        $metaContent .= "// Copy this file to your project root as .phpstorm.meta.php\n";
        $metaContent .= "// Or include it in your existing .phpstorm.meta.php file\n";
        $metaContent .= "// Run: composer generate-stubs to regenerate\n\n";
        $metaContent .= "namespace PHPSTORM_META {\n\n";

        // Add override for AbstractFactory to enable fluent interface
        $metaContent .= "    // Enable fluent interface autocomplete for factory methods\n";
        $metaContent .= "    override(\\Algoritma\\ShopwareTestUtils\\Factory\\AbstractFactory::__call(0), type(0));\n\n";

        // Collect all unique method names
        $allMethods = [];
        foreach ($factories as $factoryClass) {
            try {
                $reflection = new \ReflectionClass($factoryClass);
                $properties = $this->extractFactoryProperties($reflection);
                foreach ($properties as $property) {
                    // Removes Id suffix from property name
                    $property = \preg_replace('/Id$/i', '', (string) $property['name']);
                    $capitalizedProperty = ucfirst((string) $property);
                    $allMethods[] = "with{$capitalizedProperty}";
                    $allMethods[] = "set{$capitalizedProperty}";
                }
            } catch (\ReflectionException) {
                continue;
            }
        }

        $allMethods = array_unique($allMethods);
        sort($allMethods);

        // Add expectedArguments for autocomplete suggestions
        if ($allMethods !== []) {
            $metaContent .= "    // Autocomplete for factory method names\n";
            $metaContent .= "    expectedArguments(\n";
            $metaContent .= "        \\Algoritma\\ShopwareTestUtils\\Factory\\AbstractFactory::__call(),\n";
            $metaContent .= "        0,\n";

            foreach ($allMethods as $method) {
                $metaContent .= "        '{$method}',\n";
            }

            $metaContent .= "    );\n";
        }

        $metaContent .= "}\n";

        $metaPath = $outputDir . '/' . self::META_FILE;
        $result = @file_put_contents($metaPath, $metaContent);

        if ($result === false) {
            throw new \RuntimeException("Failed to write meta file to {$metaPath}");
        }

        return $metaPath;
    }

    /**
     * @return list<class-string<AbstractFactory>>
     */
    private function getFactoryClasses(): array
    {
        $factories = [];

        foreach ($this->factoryRegistry->getFactories() as $className) {
            if (! is_string($className)) {
                continue;
            }
            if ($className === '') {
                continue;
            }
            if (! class_exists($className)) {
                continue;
            }

            if (! is_subclass_of($className, AbstractFactory::class)) {
                continue;
            }

            $factories[] = $className;
        }

        $factories = array_values(array_unique($factories));
        sort($factories);

        return $factories;
    }

    /**
     * Generate stub content for a single factory class.
     */
    /**
     * @param \ReflectionClass<object> $reflection
     */
    private function generateFactoryStub(\ReflectionClass $reflection): string
    {
        try {
            $properties = $this->extractFactoryProperties($reflection);

            if ($properties === []) {
                return '';
            }

            $shortClassName = $reflection->getShortName();
            $stub = "    /**\n";
            foreach ($properties as $property) {
                $name = ucfirst((string) $property['name']);
                $withMethod = "with{$name}";
                $setMethod = "set{$name}";
                if ($reflection->hasMethod($withMethod)) {
                    $withMethod = null;
                }
                if ($reflection->hasMethod($setMethod)) {
                    $setMethod = null;
                }

                if ($withMethod !== null) {
                    $stub .= "     * @method self {$withMethod}(mixed \$value)\n";
                }
                if ($setMethod !== null) {
                    $stub .= "     * @method self {$setMethod}(mixed \$value)\n";
                }
            }
            $stub .= "     */\n";

            return $stub . "    class {$shortClassName} {}\n\n";
        } catch (\ReflectionException) {
            return '';
        }
    }

    /**
     * Extract property names from entity class using reflection.
     *
     * @return list<array{name: string, type: string}>
     */
    /**
     * @param \ReflectionClass<object> $reflection
     *
     * @return list<array{name: string, type: string}>
     */
    private function extractFactoryProperties(\ReflectionClass $reflection): array
    {
        try {
            // Get entity class from factory
            $factory = $reflection->newInstanceWithoutConstructor();
            $method = $reflection->getMethod('getEntityName');
            $entityName = $method->invoke($factory);

            // Retrieve properties + relations
            $properties = $this->metadataService->getEntityProperties($entityName);
            $relations = $this->metadataService->getEntityRelations($entityName);

            $result = [];

            // Add properties
            foreach ($properties as $prop) {
                $result[] = [
                    'name' => $prop['name'],
                    'type' => $prop['php_type'],  // Already mapped PHP type
                ];
            }

            // Add relations
            foreach ($relations as $rel) {
                $result[] = [
                    'name' => $rel['name'],
                    'type' => $rel['reference_class'],  // Linked entity class
                ];
            }

            return $result;
        } catch (\Exception) {
            return [];
        }
    }
}
